// Code generated by mockery v2.35.3. DO NOT EDIT.

package filesystem

import (
	io "io"
	fs "io/fs"

	os "os"

	mock "github.com/stretchr/testify/mock"

	zip "archive/zip"
)

// MockFs is an autogenerated mock type for the Fs type
type MockFs struct {
	mock.Mock
}

type MockFs_Expecter struct {
	mock *mock.Mock
}

func (_m *MockFs) EXPECT() *MockFs_Expecter {
	return &MockFs_Expecter{mock: &_m.Mock}
}

// CopyToFile provides a mock function with given fields: destination, source
func (_m *MockFs) CopyToFile(destination io.Writer, source io.Reader) (int64, error) {
	ret := _m.Called(destination, source)

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(io.Writer, io.Reader) (int64, error)); ok {
		return rf(destination, source)
	}
	if rf, ok := ret.Get(0).(func(io.Writer, io.Reader) int64); ok {
		r0 = rf(destination, source)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(io.Writer, io.Reader) error); ok {
		r1 = rf(destination, source)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockFs_CopyToFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyToFile'
type MockFs_CopyToFile_Call struct {
	*mock.Call
}

// CopyToFile is a helper method to define mock.On call
//   - destination io.Writer
//   - source io.Reader
func (_e *MockFs_Expecter) CopyToFile(destination interface{}, source interface{}) *MockFs_CopyToFile_Call {
	return &MockFs_CopyToFile_Call{Call: _e.mock.On("CopyToFile", destination, source)}
}

func (_c *MockFs_CopyToFile_Call) Run(run func(destination io.Writer, source io.Reader)) *MockFs_CopyToFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(io.Writer), args[1].(io.Reader))
	})
	return _c
}

func (_c *MockFs_CopyToFile_Call) Return(_a0 int64, _a1 error) *MockFs_CopyToFile_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockFs_CopyToFile_Call) RunAndReturn(run func(io.Writer, io.Reader) (int64, error)) *MockFs_CopyToFile_Call {
	_c.Call.Return(run)
	return _c
}

// CreateDirectory provides a mock function with given fields: path, perm
func (_m *MockFs) CreateDirectory(path string, perm fs.FileMode) error {
	ret := _m.Called(path, perm)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, fs.FileMode) error); ok {
		r0 = rf(path, perm)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockFs_CreateDirectory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateDirectory'
type MockFs_CreateDirectory_Call struct {
	*mock.Call
}

// CreateDirectory is a helper method to define mock.On call
//   - path string
//   - perm fs.FileMode
func (_e *MockFs_Expecter) CreateDirectory(path interface{}, perm interface{}) *MockFs_CreateDirectory_Call {
	return &MockFs_CreateDirectory_Call{Call: _e.mock.On("CreateDirectory", path, perm)}
}

func (_c *MockFs_CreateDirectory_Call) Run(run func(path string, perm fs.FileMode)) *MockFs_CreateDirectory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(fs.FileMode))
	})
	return _c
}

func (_c *MockFs_CreateDirectory_Call) Return(_a0 error) *MockFs_CreateDirectory_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockFs_CreateDirectory_Call) RunAndReturn(run func(string, fs.FileMode) error) *MockFs_CreateDirectory_Call {
	_c.Call.Return(run)
	return _c
}

// CreateFile provides a mock function with given fields: name
func (_m *MockFs) CreateFile(name string) (io.WriteCloser, error) {
	ret := _m.Called(name)

	var r0 io.WriteCloser
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (io.WriteCloser, error)); ok {
		return rf(name)
	}
	if rf, ok := ret.Get(0).(func(string) io.WriteCloser); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.WriteCloser)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockFs_CreateFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateFile'
type MockFs_CreateFile_Call struct {
	*mock.Call
}

// CreateFile is a helper method to define mock.On call
//   - name string
func (_e *MockFs_Expecter) CreateFile(name interface{}) *MockFs_CreateFile_Call {
	return &MockFs_CreateFile_Call{Call: _e.mock.On("CreateFile", name)}
}

func (_c *MockFs_CreateFile_Call) Run(run func(name string)) *MockFs_CreateFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockFs_CreateFile_Call) Return(_a0 io.WriteCloser, _a1 error) *MockFs_CreateFile_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockFs_CreateFile_Call) RunAndReturn(run func(string) (io.WriteCloser, error)) *MockFs_CreateFile_Call {
	_c.Call.Return(run)
	return _c
}

// FindFiles provides a mock function with given fields: pattern
func (_m *MockFs) FindFiles(pattern string) ([]string, error) {
	ret := _m.Called(pattern)

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(pattern)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(pattern)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(pattern)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockFs_FindFiles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindFiles'
type MockFs_FindFiles_Call struct {
	*mock.Call
}

// FindFiles is a helper method to define mock.On call
//   - pattern string
func (_e *MockFs_Expecter) FindFiles(pattern interface{}) *MockFs_FindFiles_Call {
	return &MockFs_FindFiles_Call{Call: _e.mock.On("FindFiles", pattern)}
}

func (_c *MockFs_FindFiles_Call) Run(run func(pattern string)) *MockFs_FindFiles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockFs_FindFiles_Call) Return(_a0 []string, _a1 error) *MockFs_FindFiles_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockFs_FindFiles_Call) RunAndReturn(run func(string) ([]string, error)) *MockFs_FindFiles_Call {
	_c.Call.Return(run)
	return _c
}

// OpenFile provides a mock function with given fields: name, flag, perm
func (_m *MockFs) OpenFile(name string, flag int, perm fs.FileMode) (*os.File, error) {
	ret := _m.Called(name, flag, perm)

	var r0 *os.File
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int, fs.FileMode) (*os.File, error)); ok {
		return rf(name, flag, perm)
	}
	if rf, ok := ret.Get(0).(func(string, int, fs.FileMode) *os.File); ok {
		r0 = rf(name, flag, perm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*os.File)
		}
	}

	if rf, ok := ret.Get(1).(func(string, int, fs.FileMode) error); ok {
		r1 = rf(name, flag, perm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockFs_OpenFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OpenFile'
type MockFs_OpenFile_Call struct {
	*mock.Call
}

// OpenFile is a helper method to define mock.On call
//   - name string
//   - flag int
//   - perm fs.FileMode
func (_e *MockFs_Expecter) OpenFile(name interface{}, flag interface{}, perm interface{}) *MockFs_OpenFile_Call {
	return &MockFs_OpenFile_Call{Call: _e.mock.On("OpenFile", name, flag, perm)}
}

func (_c *MockFs_OpenFile_Call) Run(run func(name string, flag int, perm fs.FileMode)) *MockFs_OpenFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int), args[2].(fs.FileMode))
	})
	return _c
}

func (_c *MockFs_OpenFile_Call) Return(_a0 *os.File, _a1 error) *MockFs_OpenFile_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockFs_OpenFile_Call) RunAndReturn(run func(string, int, fs.FileMode) (*os.File, error)) *MockFs_OpenFile_Call {
	_c.Call.Return(run)
	return _c
}

// OpenZip provides a mock function with given fields: name
func (_m *MockFs) OpenZip(name string) (*zip.ReadCloser, error) {
	ret := _m.Called(name)

	var r0 *zip.ReadCloser
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*zip.ReadCloser, error)); ok {
		return rf(name)
	}
	if rf, ok := ret.Get(0).(func(string) *zip.ReadCloser); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*zip.ReadCloser)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockFs_OpenZip_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OpenZip'
type MockFs_OpenZip_Call struct {
	*mock.Call
}

// OpenZip is a helper method to define mock.On call
//   - name string
func (_e *MockFs_Expecter) OpenZip(name interface{}) *MockFs_OpenZip_Call {
	return &MockFs_OpenZip_Call{Call: _e.mock.On("OpenZip", name)}
}

func (_c *MockFs_OpenZip_Call) Run(run func(name string)) *MockFs_OpenZip_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockFs_OpenZip_Call) Return(_a0 *zip.ReadCloser, _a1 error) *MockFs_OpenZip_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockFs_OpenZip_Call) RunAndReturn(run func(string) (*zip.ReadCloser, error)) *MockFs_OpenZip_Call {
	_c.Call.Return(run)
	return _c
}

// ReadFile provides a mock function with given fields: name
func (_m *MockFs) ReadFile(name string) ([]byte, error) {
	ret := _m.Called(name)

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]byte, error)); ok {
		return rf(name)
	}
	if rf, ok := ret.Get(0).(func(string) []byte); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockFs_ReadFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadFile'
type MockFs_ReadFile_Call struct {
	*mock.Call
}

// ReadFile is a helper method to define mock.On call
//   - name string
func (_e *MockFs_Expecter) ReadFile(name interface{}) *MockFs_ReadFile_Call {
	return &MockFs_ReadFile_Call{Call: _e.mock.On("ReadFile", name)}
}

func (_c *MockFs_ReadFile_Call) Run(run func(name string)) *MockFs_ReadFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockFs_ReadFile_Call) Return(_a0 []byte, _a1 error) *MockFs_ReadFile_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockFs_ReadFile_Call) RunAndReturn(run func(string) ([]byte, error)) *MockFs_ReadFile_Call {
	_c.Call.Return(run)
	return _c
}

// ReadZipFile provides a mock function with given fields: file
func (_m *MockFs) ReadZipFile(file *zip.File) (io.ReadCloser, error) {
	ret := _m.Called(file)

	var r0 io.ReadCloser
	var r1 error
	if rf, ok := ret.Get(0).(func(*zip.File) (io.ReadCloser, error)); ok {
		return rf(file)
	}
	if rf, ok := ret.Get(0).(func(*zip.File) io.ReadCloser); ok {
		r0 = rf(file)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	if rf, ok := ret.Get(1).(func(*zip.File) error); ok {
		r1 = rf(file)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockFs_ReadZipFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadZipFile'
type MockFs_ReadZipFile_Call struct {
	*mock.Call
}

// ReadZipFile is a helper method to define mock.On call
//   - file *zip.File
func (_e *MockFs_Expecter) ReadZipFile(file interface{}) *MockFs_ReadZipFile_Call {
	return &MockFs_ReadZipFile_Call{Call: _e.mock.On("ReadZipFile", file)}
}

func (_c *MockFs_ReadZipFile_Call) Run(run func(file *zip.File)) *MockFs_ReadZipFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*zip.File))
	})
	return _c
}

func (_c *MockFs_ReadZipFile_Call) Return(_a0 io.ReadCloser, _a1 error) *MockFs_ReadZipFile_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockFs_ReadZipFile_Call) RunAndReturn(run func(*zip.File) (io.ReadCloser, error)) *MockFs_ReadZipFile_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveDirectory provides a mock function with given fields: path
func (_m *MockFs) RemoveDirectory(path string) error {
	ret := _m.Called(path)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(path)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockFs_RemoveDirectory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveDirectory'
type MockFs_RemoveDirectory_Call struct {
	*mock.Call
}

// RemoveDirectory is a helper method to define mock.On call
//   - path string
func (_e *MockFs_Expecter) RemoveDirectory(path interface{}) *MockFs_RemoveDirectory_Call {
	return &MockFs_RemoveDirectory_Call{Call: _e.mock.On("RemoveDirectory", path)}
}

func (_c *MockFs_RemoveDirectory_Call) Run(run func(path string)) *MockFs_RemoveDirectory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockFs_RemoveDirectory_Call) Return(_a0 error) *MockFs_RemoveDirectory_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockFs_RemoveDirectory_Call) RunAndReturn(run func(string) error) *MockFs_RemoveDirectory_Call {
	_c.Call.Return(run)
	return _c
}

// Unzip provides a mock function with given fields: source, destination
func (_m *MockFs) Unzip(source string, destination string) error {
	ret := _m.Called(source, destination)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(source, destination)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockFs_Unzip_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unzip'
type MockFs_Unzip_Call struct {
	*mock.Call
}

// Unzip is a helper method to define mock.On call
//   - source string
//   - destination string
func (_e *MockFs_Expecter) Unzip(source interface{}, destination interface{}) *MockFs_Unzip_Call {
	return &MockFs_Unzip_Call{Call: _e.mock.On("Unzip", source, destination)}
}

func (_c *MockFs_Unzip_Call) Run(run func(source string, destination string)) *MockFs_Unzip_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockFs_Unzip_Call) Return(_a0 error) *MockFs_Unzip_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockFs_Unzip_Call) RunAndReturn(run func(string, string) error) *MockFs_Unzip_Call {
	_c.Call.Return(run)
	return _c
}

// UnzipFile provides a mock function with given fields: zipFile, destination
func (_m *MockFs) UnzipFile(zipFile *zip.File, destination string) error {
	ret := _m.Called(zipFile, destination)

	var r0 error
	if rf, ok := ret.Get(0).(func(*zip.File, string) error); ok {
		r0 = rf(zipFile, destination)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockFs_UnzipFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnzipFile'
type MockFs_UnzipFile_Call struct {
	*mock.Call
}

// UnzipFile is a helper method to define mock.On call
//   - zipFile *zip.File
//   - destination string
func (_e *MockFs_Expecter) UnzipFile(zipFile interface{}, destination interface{}) *MockFs_UnzipFile_Call {
	return &MockFs_UnzipFile_Call{Call: _e.mock.On("UnzipFile", zipFile, destination)}
}

func (_c *MockFs_UnzipFile_Call) Run(run func(zipFile *zip.File, destination string)) *MockFs_UnzipFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*zip.File), args[1].(string))
	})
	return _c
}

func (_c *MockFs_UnzipFile_Call) Return(_a0 error) *MockFs_UnzipFile_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockFs_UnzipFile_Call) RunAndReturn(run func(*zip.File, string) error) *MockFs_UnzipFile_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockFs creates a new instance of MockFs. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockFs(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockFs {
	mock := &MockFs{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
